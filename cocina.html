<!DOCTYPE html>
<html class="dark" lang="es">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>KDS | Cocina Caliente</title>
    
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=Noto+Sans:wght@400;500;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet"/>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>

    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: { 
                        "primary": "#1392ec", 
                        "background-dark": "#0f1115", 
                        "card-dark": "#1a1d24", 
                        "timer-green": "#22c55e", 
                        "timer-yellow": "#eab308", 
                        "timer-red": "#ef4444",
                        "cold-blue": "#06b6d4" 
                    },
                    fontFamily: { "display": ["Space Grotesk", "sans-serif"], "body": ["Noto Sans", "sans-serif"] },
                    boxShadow: { 
                        'neon-blue': '0 0 10px rgba(19, 146, 236, 0.3)', 
                        'neon-green': '0 0 10px rgba(34, 197, 94, 0.2)', 
                        'neon-red': '0 0 15px rgba(239, 68, 68, 0.4)',
                        'neon-cold': '0 0 10px rgba(6, 182, 212, 0.3)'
                    },
                    animation: { 'flash': 'flash 1.5s infinite' },
                    keyframes: { flash: { '0%, 100%': { opacity: '1' }, '50%': { opacity: '0.5' } } }
                },
            },
        }
    </script>
    <style>
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes pulse-red { 0%, 100% { box-shadow: 0 0 20px rgba(239,68,68,0.2); background-color: #7f1d1d; } 50% { box-shadow: 0 0 50px rgba(239,68,68,0.6); background-color: #991b1b; } }
        .void-card { animation: pulse-red 1.2s infinite; border: 4px solid #ef4444; }
        .trigger-item { background: repeating-linear-gradient(45deg, #16a34a, #16a34a 10px, #15803d 10px, #15803d 20px); }
        .hibernating { opacity: 0.85; filter: grayscale(0.2); border: 1px dashed #555; order: 99; }
        .waiting-alive { color: #06b6d4; font-weight: bold; opacity: 1 !important; text-decoration: none !important; }
    </style>
</head>
<body class="bg-[#f6f7f8] dark:bg-background-dark font-display text-white overflow-x-hidden min-h-screen flex flex-col transition-colors duration-300">

    <audio id="sound-new-order" src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3"></audio>
    <audio id="sound-alarm" src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3"></audio>

    <header class="flex items-center justify-between p-4 bg-[#14171c] border-b border-white/5 sticky top-0 z-50 backdrop-blur-md bg-opacity-90">
        <div class="flex items-center gap-4">
            <div class="flex items-center justify-center size-10 rounded-full bg-white/5"><span class="material-symbols-outlined text-primary">skillet</span></div>
            <div><h1 class="text-xl font-bold tracking-tight text-white leading-none">KDS COCINA</h1><p id="connection-status" class="text-xs text-green-500 font-medium tracking-wide mt-0.5 flex items-center gap-1"><span class="size-2 rounded-full bg-green-500 animate-pulse"></span> ONLINE</p></div>
        </div>
        <div class="flex items-center gap-3 bg-[#1e232b] px-3 py-1.5 rounded-lg border border-white/5"><span class="material-symbols-outlined text-primary text-[20px]">schedule</span><p id="clock-display" class="text-lg font-bold tracking-widest text-white">00:00</p></div>
    </header>

    <div class="flex gap-3 p-4 overflow-x-auto hide-scrollbar border-b border-white/5 bg-[#14171c]/50">
        <button onclick="app.fetchOrders()" class="flex h-9 shrink-0 items-center justify-center gap-x-2 rounded-lg bg-primary text-white pl-3 pr-4 shadow-neon-blue active:scale-95 transition-all"><span class="material-symbols-outlined text-[18px]">sync</span><p class="text-sm font-bold">Refrescar</p></button>
        <div class="flex h-9 shrink-0 items-center justify-center gap-x-2 rounded-lg bg-[#232932] border border-white/5 pl-3 pr-4"><span class="material-symbols-outlined text-timer-yellow text-[18px]">timer</span><p id="count-pending" class="text-gray-300 text-sm font-medium">Pendientes: 0</p></div>
    </div>

    <main id="orders-container" class="flex-1 p-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 auto-rows-min pb-20">
        <div class="col-span-full flex flex-col items-center justify-center py-20 opacity-50"><span class="material-symbols-outlined text-4xl animate-spin mb-4">progress_activity</span><p class="text-sm tracking-widest uppercase">Cargando...</p></div>
    </main>

    <script>
        const CONFIG = {
            apiUrl: "https://script.google.com/macros/s/AKfycbziajyL10l9cnis2NZ1k4UDCYylbysU-PBNw930e-wRdBpdYeBZHOYhsT5YOhkNKT4O/exec", 
            pollInterval: 8000,
            waitKeywords: ['luego', 'postre', 'espera', 'despues', 'turno', 'siguiente'], 
            triggerKeywords: ['servir', 'sale', 'ya', 'marcha'] 
        };

        const app = {
            orders: [],
            lastOrderCount: 0,
            hibernatingIds: new Set(),
            cachedOrders: {}, // Memoria local de respaldo

            init: () => {
                app.startClock();
                app.fetchOrders();
                setInterval(() => app.fetchOrders(), CONFIG.pollInterval);
                setInterval(() => app.updateTimers(), 1000);
            },

            startClock: () => { setInterval(() => { const now = new Date(); document.getElementById('clock-display').innerText = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}); }, 1000); },

            parseItemsSmart: (itemsString) => {
                if (!itemsString) return [];
                let cleanString = String(itemsString).trim();
                if (cleanString.startsWith('|')) cleanString = cleanString.substring(1);
                const items = [];
                let currentItem = "";
                let bracketDepth = 0;
                for (let i = 0; i < cleanString.length; i++) {
                    const char = cleanString[i];
                    if (char === '[') bracketDepth++;
                    else if (char === ']') bracketDepth--;
                    if ((char === ',' || char === '|') && bracketDepth === 0) { if (currentItem.trim()) items.push(currentItem.trim()); currentItem = ""; } else { currentItem += char; }
                }
                if (currentItem.trim()) items.push(currentItem.trim());
                return items.map(rawItem => {
                    let name = rawItem.trim();
                    let isChecked = false;
                    // DETECCI√ìN DE CHECK DEL SERVIDOR (NUEVO EN V18)
                    if (name.includes('‚úî') || name.includes('‚úì')) { isChecked = true; name = name.replace(/‚úî|‚úì/g, '').trim(); }
                    const match = name.match(/^(.*?)\s*\[(.*?)\]$/);
                    const cleanName = match ? match[1].trim() : name;
                    const notes = match ? match[2].split(',').map(n => n.trim()) : [];
                    return { name: cleanName, notes, isChecked, original: rawItem };
                });
            },

            // --- L√ìGICA V18: CONSOLIDACI√ìN SIN DUPLICADOS (Anti-Eco) ---
            consolidateOrders: (rawData) => {
                const grouped = {};
                
                rawData.forEach(order => {
                    const idStr = String(order.id).trim();
                    if (!grouped[idStr]) {
                        grouped[idStr] = { ...order };
                    } else {
                        const existingItems = grouped[idStr].items.split('|').map(s => s.trim());
                        const newItems = order.items.split('|').map(s => s.trim());
                        
                        // Usamos un Set para eliminar duplicados exactos
                        const uniqueSet = new Set(existingItems);
                        newItems.forEach(item => { if (item) uniqueSet.add(item); });
                        
                        grouped[idStr].items = Array.from(uniqueSet).join(" | ");
                        if (order.total < 0) grouped[idStr].total = -1;
                    }
                });
                return Object.values(grouped);
            },

            fetchOrders: async () => {
                const statusEl = document.getElementById('connection-status');
                try {
                    statusEl.innerHTML = '<span class="size-2 rounded-full bg-yellow-500 animate-pulse"></span> BUSCANDO...';
                    const res = await fetch(`${CONFIG.apiUrl}?action=get_orders&t=${Date.now()}`);
                    const rawData = await res.json();
                    
                    if (!Array.isArray(rawData)) throw new Error("Error datos");

                    const consolidatedData = app.consolidateOrders(rawData);
                    const incomingIds = new Set(consolidatedData.map(o => String(o.id)));
                    
                    app.hibernatingIds.forEach(hibId => {
                        if (!incomingIds.has(hibId) && app.cachedOrders[hibId]) {
                            consolidatedData.push(app.cachedOrders[hibId]);
                        }
                    });

                    app.orders = consolidatedData;
                    
                    app.orders.forEach(o => { app.cachedOrders[String(o.id)] = o; });

                    app.renderOrders();
                    
                    const visibleOrders = app.countVisibleOrders();
                    if (visibleOrders > app.lastOrderCount) { 
                        try { document.getElementById('sound-new-order').play(); } catch(e){} 
                    }
                    app.lastOrderCount = visibleOrders;
                    
                    document.getElementById('count-pending').innerText = `Pendientes: ${visibleOrders}`; 
                    statusEl.innerHTML = '<span class="size-2 rounded-full bg-green-500"></span> ONLINE';
                } catch (e) {
                    console.error(e);
                    statusEl.innerHTML = '<span class="size-2 rounded-full bg-red-500"></span> REINTENTANDO';
                }
            },

            countVisibleOrders: () => {
                return document.querySelectorAll('.order-card:not(.void-card)').length;
            },

            // --- L√ìGICA V18: DEPURACI√ìN INTELIGENTE (Canibalismo: Trigger/Nuevo mata a Wait) ---
            analyzeOrder: (order) => {
                const rawItems = app.parseItemsSmart(String(order.items));
                
                // Filtro extra de seguridad visual
                const uniqueKeys = new Set();
                const items = [];
                rawItems.forEach(item => {
                    if(!uniqueKeys.has(item.original)){
                        uniqueKeys.add(item.original);
                        items.push(item);
                    }
                });
                
                let hasTrigger = false;
                let hasWaiting = false; 
                let hasNewActive = false; 

                // PASO 1: Contar "Activos" (Nuevos, Triggers y los que ya tienen Check)
                const activeCounts = {};

                const categorized = items.map(item => {
                    const isTrigger = CONFIG.triggerKeywords.some(k => item.name.toLowerCase().includes(k));
                    const isWaitingType = item.notes.some(n => CONFIG.waitKeywords.some(k => n.toLowerCase().includes(k)));

                    if (isTrigger) hasTrigger = true;

                    let status = 'NEW';
                    if (item.isChecked) status = 'OLD';

                    if (status === 'NEW' && isTrigger) status = 'TRIGGER';
                    else if (status === 'NEW' && isWaitingType) {
                        status = 'WAITING';
                    } else if (status === 'NEW') {
                        hasNewActive = true;
                    }

                    // CORRECCI√ìN CLAVE V18:
                    // Si el √≠tem es TRIGGER, NUEVO o ya est√° marcado como OLD (Checked),
                    // cuenta como "Activo" y tiene derecho a matar a su versi√≥n WAITING.
                    if (status === 'TRIGGER' || status === 'NEW' || status === 'OLD') {
                        const key = item.name.trim().toLowerCase();
                        activeCounts[key] = (activeCounts[key] || 0) + 1;
                    }

                    return { ...item, status, isWaitingType };
                });

                // PASO 2: Filtrado Inteligente
                const finalItems = categorized.filter(item => {
                    if (item.status === 'WAITING') {
                        const key = item.name.trim().toLowerCase();
                        // Si hay uno Activo (Blanco/Trigger/Checked) con el mismo nombre...
                        if (activeCounts[key] > 0) {
                            activeCounts[key]--;
                            return false; // ...el √≠tem azul (WAITING) muere (se oculta).
                        }
                    }
                    return true;
                });

                hasWaiting = finalItems.some(i => i.status === 'WAITING');

                if (hasTrigger) {
                    finalItems.forEach(item => {
                        if (item.status === 'WAITING' || (item.status === 'OLD' && item.isWaitingType)) {
                            item.status = 'REVIVED';
                        }
                    });
                }

                const isHibernating = !hasNewActive && hasWaiting && !hasTrigger;

                return { items: finalItems, hasTrigger, hasWaiting, isHibernating, hasNewActive };
            },

            completeOrder: async (id, btnElement) => {
                const card = btnElement.closest('.order-card');
                const isVoid = card.classList.contains('void-card');
                
                if(!isVoid && !confirm("¬øConfirmar acci√≥n?")) return;

                const currentOrder = app.orders.find(o => o.id == id);
                if (!currentOrder) return;

                const analysis = app.analyzeOrder(currentOrder);

                if (!isVoid && analysis.hasWaiting && !analysis.hasTrigger) {
                    btnElement.innerHTML = '<span class="material-symbols-outlined animate-spin">sync</span> GUARDANDO...';
                    
                    // Al guardar, usamos un SET para evitar duplicados en el env√≠o al servidor
                    const uniqueItemsToSend = new Set();
                    
                    analysis.items.forEach(item => {
                        let prefix = "";
                        // Ponemos check a todo lo que NO sea espera pura o trigger
                        if ((item.status === 'NEW' || item.isChecked) && item.status !== 'TRIGGER') prefix = "‚úî ";
                        if (item.status === 'WAITING' && !item.isChecked) prefix = "";
                        
                        const noteStr = item.notes.length > 0 ? ` [${item.notes.join(', ')}]` : "";
                        uniqueItemsToSend.add(prefix + item.name + noteStr);
                    });

                    const newItemsString = Array.from(uniqueItemsToSend).join(" | ");

                    try {
                        await fetch(CONFIG.apiUrl, {
                            method: 'POST', mode: 'no-cors', headers: {'Content-Type': 'text/plain'},
                            body: JSON.stringify({ type: 'update_items', id: id, newItems: newItemsString })
                        });
                        setTimeout(() => app.fetchOrders(), 1000);
                    } catch (e) { alert("Error guardando en servidor"); }

                } else {
                    const statusToSend = isVoid ? "ANULADO" : "LISTO";
                    card.style.transform = 'scale(0.9)'; card.style.opacity = '0';
                    setTimeout(() => card.remove(), 300);

                    try {
                        await fetch(CONFIG.apiUrl, {
                            method: 'POST', mode: 'no-cors', headers: {'Content-Type': 'text/plain'},
                            body: JSON.stringify({ type: 'complete_order', id: id, finalStatus: statusToSend })
                        });
                    } catch (e) { console.log("Guardado offline"); }
                }
            },

            renderOrders: () => {
                const container = document.getElementById('orders-container');
                
                const htmlParts = app.orders.map(order => {
                    const itemsText = String(order.items).toUpperCase();
                    const isVoid = order.total < 0 || itemsText.includes("ANULADO") || itemsText.includes("CANCELADO");

                    if (isVoid) {
                         return `<div class="order-card flex flex-col bg-red-900 rounded-xl overflow-hidden shadow-2xl relative h-fit void-card z-50 order-first" data-id="${order.id}"><div class="bg-red-600 text-white p-4 flex justify-between items-center animate-pulse"><h2 class="text-3xl font-black tracking-tighter">‚õî ANULADO</h2><span class="text-2xl font-bold">#${order.id}</span></div><div class="p-6 bg-red-950 flex flex-col items-center justify-center text-center space-y-4"><span class="material-symbols-outlined text-6xl text-red-500">block</span><p class="text-xl font-bold text-white uppercase">NO PREPARAR</p><button onclick="app.completeOrder(${order.id}, this)" class="w-full h-16 bg-white text-red-900 font-black text-xl tracking-widest hover:bg-gray-200 transition-colors uppercase">CONFIRMAR</button></div></div>`;
                    }

                    const { items, hasTrigger, hasWaiting, isHibernating, hasNewActive } = app.analyzeOrder(order);

                    const allOld = items.every(i => i.status === 'OLD');
                    if (allOld && !hasWaiting && !hasTrigger && !hasNewActive && !isHibernating) return '';

                    const triggers = items.filter(i => i.status === 'TRIGGER');
                    const actives = items.filter(i => i.status === 'NEW' || i.status === 'REVIVED');
                    const waiting = items.filter(i => i.status === 'WAITING');
                    const olds = items.filter(i => i.status === 'OLD');

                    const renderItem = (item, type) => {
                        let bgColor = "", textColor = "text-white", icon = "circle", iconColor = "text-primary";
                        let extraStyle = "";
                        
                        if (type === 'TRIGGER') {
                            bgColor = "trigger-item animate-pulse border-2 border-green-400 mb-4 scale-105 shadow-xl";
                            icon = "notifications_active"; 
                            textColor = "text-white font-black text-2xl tracking-widest text-center w-full";
                        } else if (type === 'WAITING') {
                            textColor = "text-cold-blue waiting-alive";
                            icon = "hourglass_top";
                            iconColor = "text-cold-blue";
                            extraStyle = "opacity-100";
                        } else if (type === 'OLD') {
                            textColor = "text-gray-500 line-through decoration-2";
                            icon = "check_circle";
                            iconColor = "text-gray-600";
                            extraStyle = "opacity-40 text-sm";
                        } else if (type === 'REVIVED') {
                            bgColor = "bg-green-500/10 border border-green-500/30";
                            textColor = "text-white font-bold";
                            icon = "priority_high";
                            iconColor = "text-green-400";
                        }

                        const notesHtml = item.notes.map(n => `<span class="inline-flex items-center text-xs ml-1 text-gray-400 italic">${n}</span>`).join(' ');

                        return `<div class="p-2 rounded flex items-start gap-2 ${bgColor} ${extraStyle}">
                            ${type === 'TRIGGER' ? '' : `<span class="material-symbols-outlined text-sm ${iconColor} mt-1">${icon}</span>`}
                            <div class="flex-1">
                                <p class="leading-tight uppercase ${textColor}">${item.name} ${type === 'TRIGGER' ? 'üîî' : ''}</p>
                                ${notesHtml ? `<div class="mt-0.5 flex flex-wrap gap-1">${notesHtml}</div>` : ''}
                            </div>
                        </div>`;
                    };

                    let btnText = "LISTO";
                    let btnIcon = "check_circle";
                    let btnColor = "bg-primary hover:bg-blue-500";
                    let hibernationBanner = "";
                    let cardClass = "";

                    if (isHibernating) {
                        cardClass = "hibernating"; 
                        hibernationBanner = `<div class="bg-yellow-600/20 text-yellow-500 text-center py-1 text-xs font-bold uppercase tracking-widest border-y border-yellow-600/30 animate-pulse">‚è≥ EN ESPERA...</div>`;
                        btnText = "FORZAR CIERRE";
                        btnIcon = "close";
                        btnColor = "bg-gray-700 hover:bg-gray-600 border border-white/10";
                    } else if (hasTrigger) {
                        btnText = "OIDO / SERVIR";
                        btnColor = "bg-green-600 hover:bg-green-500 shadow-neon-green animate-bounce";
                    } else if (hasWaiting && actives.length > 0) {
                        btnText = "DESPACHAR PARCIAL"; 
                        btnIcon = "local_shipping";
                        btnColor = "bg-blue-600 hover:bg-blue-500";
                    }

                    const triggersHtml = triggers.map(i => renderItem(i, 'TRIGGER')).join('');
                    const activesHtml = actives.map(i => renderItem(i, i.status)).join('');
                    const waitingHtml = waiting.length ? `<div class="border-t border-white/10 my-2 pt-2"><p class="text-[10px] text-cold-blue uppercase font-bold tracking-widest mb-1 flex items-center gap-1"><span class="material-symbols-outlined text-[12px]">ac_unit</span> PENDIENTES</p>${waiting.map(i => renderItem(i, 'WAITING')).join('')}</div>` : '';
                    const oldsHtml = olds.length ? `<div class="border-t border-white/5 my-2 pt-2"><p class="text-[10px] text-gray-700 uppercase font-bold tracking-widest mb-1">ENVIADO</p>${olds.map(i => renderItem(i, 'OLD')).join('')}</div>` : '';

                    const startTime = new Date(order.time).getTime();
                    
                    return `<div class="order-card flex flex-col bg-card-dark rounded-xl border border-white/5 overflow-hidden shadow-lg group relative h-fit transition-all duration-500 ${hasTrigger ? 'shadow-neon-green ring-1 ring-green-500/30' : ''} ${cardClass}" data-time="${startTime}">
                        ${hibernationBanner}
                        <div class="status-stripe absolute top-0 left-0 w-1.5 h-full ${hasTrigger ? 'bg-green-500 animate-pulse' : 'bg-timer-green'} transition-colors duration-500"></div>
                        <div class="p-4 pl-6 flex justify-between items-start bg-white/5 border-b border-white/5">
                            <div>
                                <div class="flex items-baseline gap-2"><h2 class="text-2xl font-bold text-white tracking-tight">MESA ${order.mesa}</h2><span class="text-sm text-gray-400 font-medium">#${order.id}</span></div>
                                <div class="flex items-center gap-1.5 mt-1"><span class="material-symbols-outlined text-gray-500 text-[16px]">person</span><p class="text-sm text-gray-400 font-bold uppercase">${order.mozo}</p></div>
                            </div>
                            <div class="timer-box bg-white/5 border border-white/10 px-3 py-1 rounded flex items-center gap-2 transition-colors duration-500"><span class="material-symbols-outlined text-[18px]">timer</span><span class="timer-display text-xl font-bold tracking-wider font-display">00:00</span></div>
                        </div>
                        <div class="px-4 pl-6 py-4 flex-1 space-y-1">
                            ${triggersHtml}
                            ${activesHtml}
                            ${waitingHtml}
                            ${oldsHtml}
                        </div>
                        <div class="p-4 pl-6 bg-[#1f242d] border-t border-white/5 mt-auto">
                            <button onclick="app.completeOrder(${order.id}, this)" class="w-full h-12 ${btnColor} text-white rounded-lg font-bold text-base tracking-wide shadow-neon-blue transition-all flex items-center justify-center gap-2 active:scale-95">
                                <span class="material-symbols-outlined">${btnIcon}</span>
                                ${btnText}
                            </button>
                        </div>
                    </div>`;
                }).join('');

                container.innerHTML = htmlParts.length ? htmlParts : `<div class="col-span-full flex flex-col items-center justify-center py-20 text-gray-600"><span class="material-symbols-outlined text-6xl mb-4">check_circle</span><p class="text-xl font-bold">¬°Cocina Limpia!</p></div>`;
                app.updateTimers();
            },

            updateTimers: () => {
                const now = new Date().getTime();
                document.querySelectorAll('.order-card').forEach(card => {
                    if(card.classList.contains('void-card') || card.classList.contains('hibernating')) return;
                    const startTime = parseInt(card.getAttribute('data-time'));
                    if(!startTime) return;
                    const diff = now - startTime;
                    const minutes = Math.floor(diff / 60000);
                    const seconds = Math.floor((diff % 60000) / 1000);
                    const timeString = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
                    const timerDisplay = card.querySelector('.timer-display');
                    if(timerDisplay) timerDisplay.innerText = timeString;
                    const stripe = card.querySelector('.status-stripe');
                    const timerBox = card.querySelector('.timer-box');
                    
                    if(stripe.classList.contains('bg-green-500')) return; 

                    card.classList.remove('critical-pulse', 'border-red-500/30');
                    if(timerBox) timerBox.className = "timer-box px-3 py-1 rounded flex items-center gap-2 transition-colors duration-500 border";
                    if (minutes >= 20) {
                        if(stripe) stripe.className = "status-stripe absolute top-0 left-0 w-1.5 h-full bg-timer-red shadow-neon-red";
                        if(timerBox) timerBox.classList.add("bg-timer-red/10", "border-timer-red/30", "text-timer-red");
                        card.classList.add('critical-pulse', 'border-red-500/30');
                    } else if (minutes >= 10) {
                        if(stripe) stripe.className = "status-stripe absolute top-0 left-0 w-1.5 h-full bg-timer-yellow shadow-[0_0_10px_rgba(234,179,8,0.3)]";
                        if(timerBox) timerBox.classList.add("bg-timer-yellow/10", "border-timer-yellow/20", "text-timer-yellow");
                    } else {
                        if(stripe) stripe.className = "status-stripe absolute top-0 left-0 w-1.5 h-full bg-timer-green shadow-[0_0_10px_rgba(34,197,94,0.3)]";
                        if(timerBox) timerBox.classList.add("bg-timer-green/10", "border-timer-green/20", "text-timer-green");
                    }
                });
            }
        };
        app.init();
    </script>
</body>
</html>